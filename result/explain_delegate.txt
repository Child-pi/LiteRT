How to Create a TFLite Delegate (Example: my_op_add_test and my_op_mul_test)
=====================================================

Creating a delegate in LiteRT (formerly TFLite) allows you to offload the execution of specific operations to a specialized hardware accelerator or a custom highly-optimized software implementation.

In this example, we have split a combined delegate into two separate specialized delegates:
1. `my_op_add_test`: Handles the built-in `ADD` operator.
2. `my_op_mul_test`: Handles the built-in `MUL` operator.

Key Components of a Delegate:
----------------------------

1. TfLiteDelegate Structure:
   The core of any delegate is the `TfLiteDelegate` C structure. It contains function pointers that LiteRT calls to interact with the delegate. The most important one is `Prepare`.

2. SimpleDelegateInterface:
   To make it easier to write delegates in C++, LiteRT provides a helper class called `SimpleDelegateInterface`. This wraps the low-level C API and allows you to focus on two main things:
   - Defining which nodes are supported.
   - Defining how those nodes should be executed.

3. Identifying Supported Nodes (IsNodeSupportedByDelegate):
   The delegate's first task is to look at the TFLite graph and decide which operations it can handle.
   In `my_op_add_test_delegate.cc`:
   ```cpp
   bool IsNodeSupportedByDelegate(const TfLiteRegistration* registration, ...) {
     if (registration->builtin_code == kTfLiteBuiltinAdd) {
       // Check if data types are supported (e.g., float32)
       return true;
     }
     return false;
   }
   ```

4. Delegate Kernel (SimpleDelegateKernelInterface):
   Once the delegate claims a set of nodes, LiteRT replaces them with a single "delegate node". This node is managed by a "Delegate Kernel".
   The kernel has three main methods:
   - Init(): Called when the delegate node is created. Used to store information about the original nodes being replaced.
   - Prepare(): Called when the graph is being prepared. Used to check shapes and allocate any necessary intermediate buffers.
   - Eval(): Called during inference. This is where the actual computation happens.

5. Implementation of the Operation:
   In the `Eval()` method of our delegate kernel, we included the necessary reference headers (e.g., `tflite/kernels/internal/reference/add.h`) and called the corresponding functions (e.g., `reference_ops::Add`).

6. Creation and Deletion:
   Finally, you provide C-style functions to create and delete the delegate instance.
   ```cpp
   TfLiteDelegate* TfLiteMyOpAddTestDelegateCreate(const MyOpAddTestDelegateOptions* options);
   void TfLiteMyOpAddTestDelegateDelete(TfLiteDelegate* delegate);
   ```

Summary of Steps to create these delegates:
--------------------------------------
1. Created `tflite/delegates/my_op_test/` directory.
2. Defined the options and C API in `my_op_add_test_delegate.h` and `my_op_mul_test_delegate.h`.
3. Implemented the logic in separate `.cc` files using `SimpleDelegateInterface`.
4. Updated the build system (CMake and BUILD files) to include the new files and their unit tests.
5. Verified the implementation with dedicated unit tests.
